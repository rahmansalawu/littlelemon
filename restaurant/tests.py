from django.test import TestCase
from . models import Booking, Menu   # import the model you need the test
from .serializers import MenuSerializer
from django.urls import reverse
from rest_framework import status
# Create your tests here.
class MenuViewTest(TestCase):
    def setUp(self):
        Menu.objects.create(title='Amala',price=10,inventory=50)
        Menu.objects.create(title="Pizza", price=9.99, inventory=10)
        Menu.objects.create(title="Burger", price=7.99, inventory=5)
        Menu.objects.create(title="Salad", price=5.99, inventory=8)
        #self.assertEqual(item, "Amala : 10")

    def test_get_item(self):
        item = Menu.objects.create(title="IceCream", price=80, inventory=100)
        #self.assertEqual(item, "IceCream : 80")
        self.assertEqual(item.title, "IceCream")
        self.assertEqual(item.price, 80)

    def test_get_all_menu_items(self):
            
        url = reverse('menu-items')  # 'menu-items-list' is the default name generated by DRF for list views
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 4)  # Ensure four items are returned

        # Additional checks can be made here to ensure the response data is correct
        expected_titles = {'Amala', 'Pizza', 'Burger', 'Salad'}
        returned_titles = {item['title'] for item in response.data}
        self.assertEqual(expected_titles, returned_titles)

""" 
    def test_getall(self):
        response = self.client.get(reverse('restaurant:menu-items'))
        menus = Menu.objects.all()
        serializer = MenuSerializer(menus,many=True)
        self.assertEqual(response.status_code, 200)
        # Check if the serialized data equals the response data
        self.assertEqual(response.data, serializer.data)
"""